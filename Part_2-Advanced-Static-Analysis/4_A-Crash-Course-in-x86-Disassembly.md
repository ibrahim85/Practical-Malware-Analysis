#### 4. A Crash Course in x86 Disassembly

###### Levels of Abstraction

![Image of x86](images/1.jpeg)

###### The x86 Architecture

- Von Neumann architecture

![Image of x86](images/2.jpeg)

- Main Memory

![Image of x86](images/3.jpeg)

- Instructions

![Image of x86](images/4.jpeg)

- Opcodes and Endianness

![Image of x86](images/5.jpeg)

- Operands

	- Immediate operands - ```0x42```
	- Register - ```eax```
	- Memory address - ```[eax]```

- Registers

	- Multiplication and division instructions always use ``EAX`` and ``EDX``
	- Return value stored in ``EAX``

![Image of x86](images/6.jpeg)

![Image of x86](images/7.jpeg)

- Flags

Flag | Full Form | When is it set?
-----|-----------|---------------------------------
ZF | Zero Flag | result of an operation is equal to zero
CF | Carry Flag | result of an operation is too large or too small
SF | Sign Flag | result of an operation is negative or cleared when the result is positive
TF | Trap Flag | x86 processor will execute only one instruction at a time if this flag is set

- EIP

Contains the memory address of the next instruction to be executed

- Simple Instructions

![Image of x86](images/8.jpeg)

![Image of x86](images/9.jpeg)

```mov eax, [ebx+8]``` &rarr; ```eax = 0x20```

```lea eax, [ebx+8]``` &rarr; ```eax = 0xB30048```

- Arithmetic

	![Image of x86](images/10.jpeg)

	- mul

		```
		mul value
		```
		
		Multiplies ```EAX``` by value.
		
		Result is stored as a 64-bit value across two registers: ```EDX``` (most significant 32 bits) and ```EAX``` (least significant 32 bits)
		
	- div

		```
		div value
		```
		
		Does the same thing as ``mul``, except in the opposite direction
		
		Result of the division operation is stored in ``EAX``, and the remainder is stored in ``EDX``
		
		![Image of x86](images/11.jpeg)
		
	- shr and shl

		Values fall off
		
		```
		shr destination, count
		shl destination, count
		```
		
		The ``shr`` and ``shl`` instructions shift the bits in the destination operand to the right and left, respectively, by the number of bits specified in the count operand. Bits shifted beyond the destination boundary are first shifted into the ``CF`` flag. Zero bits are filled in during the shift. 
		
		Eg - binary value ``1000`` and shift it right by ``1``, the result is ``0100``
		
		``CF`` flag contains the last bit shifted out of the destination operand.
		
	- ror and rol

		Values get rotated to the other end 
		
		```
		ror destination, count
		rol destination, count
		```
		
		``ror`` and ``rol``, are similar to the shift instructions, except the shifted bits that “fall off” with the shift operation are rotated to the other end. In other words, during a right rotation (ror) the least significant bits are rotated to the most significant position. Left rotation (rol) is the exact opposite. 
		
![Image of x86](images/12.jpeg)
		
- Optimization

Shifting &rarr; Optimization &rarr; Multiplication 

Normal | Optimized 
-------|-----------
shl eax, 1 | Multiply EAX by 2
shl eax, 2 | Multiply EAX by 4
shl eax, 3 | Multiply EAX by 8
 
```Shifting``` an operand to the ```left n bits``` multiplies it by ```2^n```.

Encryption or Compression function -  ```xor, or, and, shl, ror, shr, or rol```

- NOP

No Operation

```nop``` = ```xhcg eax, eax```

- The Stack

Stores local variables, parameters, and the return address

Function Prologue

```sh
push ebp
mov ebp, esp
sub esp, N
```

Optimized Function Prologue

```sh
enter N, 0
```

Function Epilogue

```sh
mov esp, ebp
pop ebp
ret
```

Optimized Function Epilogue

```sh
leave
ret
```

![Image of x86](images/13.jpeg)

``pusha and pushad`` &rarr; push all the registers onto the stack

``popa and popad`` &rarr; pop all the registers off the stack

``pusha`` pushes the 16-bit registers on the stack in the following order &rarr; ``AX, CX, DX, BX, SP, BP, SI, DI``
``pushad`` pushes the 32-bit registers on the stack in the following order &rarr; ``EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI``

Compilers rarely use these instructions, so seeing them often indicates someone hand-coded assembly and/or shellcode.


